P110

isort3:
由于内循环中总是给变量t赋相同的值（x[i]的初始值），
所以我们可以将上面两个含t的赋值语句移出内循环外，
并相应地修改比较语句，从而得到isort3:
for i = [i, n)
	t = x[i]
	for (j = i; j > 0 && x[j-1] > t; j--)
		x[j] = x[j-1]
	x[j] = t
(Notes: 实验结果表明isort3的效率比isort1提高一倍.
测试数据为50，000的情况下，用"gcc isort3.cpp"编译,运行时间约为2.99s;
)

isort2:
在isort1的基础上，将swap实现为内联(inline)函数，以增加速度。
(Notes: 从实验结果来看，加上“inline”并没有提高运行速度；一个可能的原因是，isort1的程序，编译器已经作了优化;
		如果将swap直接在代码中展开，则代码效率可用优化30%左右；	
测试数据为50，000的情况下，用"gcc isort2.cpp"编译,
如果将swap实现为内联(inline)函数, 运行时间约为6.43s;
如果将swap直接在代码中展开,运行时间约为5.05s;
)

isort1:
筛选过程通过一个从右到左的循环实现，该循环使用变量j跟踪被筛选的元素。
只要该元素具有前驱（即j>0）且没有到达最终位置（即该元素小于它的前驱），循环就交换该元素和它的前驱。
完整的程序isort1如下所示：
for i = [1, n)
	for (j = i; j > 0 && x[j-1] > x[j]; j--)
		swap(j-1, j)
Notes:
改变gcc 优化选项（-O）对代码运行效率改变很大：
测试数据为50，000的情况下，
如果用"gcc isort1.cpp"编译，运行时间约为6.43s;
如果用“gcc -O1 isort1.cpp”编译，运行时间约为1.81s；
如果用“gcc -O2 isort1.cpp”编译，运行时间约为0.68s；
如果用“gcc -O3 isort1.cpp”编译，运行时间约为1.14s；
如果用“gcc -O4 isort1.cpp”编译，运行时间约为1.13s；
如果用“gcc -O5 isort1.cpp”编译，运行时间约为1.14s；
如果用“gcc -O isort1.cpp”编译，运行时间约为1.8s；
